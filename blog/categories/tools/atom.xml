<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Tools | Foolishwolf's Code Blog]]></title>
  <link href="http://foolishwolf.github.io/blog/categories/tools/atom.xml" rel="self"/>
  <link href="http://foolishwolf.github.io/"/>
  <updated>2017-06-05T11:51:10+08:00</updated>
  <id>http://foolishwolf.github.io/</id>
  <author>
    <name><![CDATA[Foolishwolf]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[从TFS获取指定日期后的最新版本文件]]></title>
    <link href="http://foolishwolf.github.io/blog/2017/06/05/cong-tfshuo-qu-zhi-ding-ri-qi-hou-de-zui-xin-ban-ben-wen-jian/"/>
    <updated>2017-06-05T10:34:31+08:00</updated>
    <id>http://foolishwolf.github.io/blog/2017/06/05/cong-tfshuo-qu-zhi-ding-ri-qi-hou-de-zui-xin-ban-ben-wen-jian</id>
    <content type="html"><![CDATA[<h3>背景介绍</h3>

<p>对于迭代开发的版本管理来说，最经常的事情，就是整理每次迭代的版本。特别是时间紧张的时候，每天可能都需要下发版本进行测试。<br/>
之前各开发人员填写版本下发清单，然后根据清单来整理版本和部署执行码，难免会有漏填的情况。而每次迭代增加新的目录，也过于繁琐。<br/>
其实对于每个增量版本来说，起始时间都是上次版本的结束时间。在当前版本开发结束后，版本管理员可以暂时锁定TFS，禁止开发人员签入，然后以上次版本的结束时间为起点，获取TFS上签入的所有执行文件，这些文件就是当前版本的全部增量集。<br/>
然而，VS的IDE中，并没有实现这一功能，所以只能利用TFS的API来编码实现。</p>

<h3>程序实现</h3>

<pre><code class="csharp">/*
    程序功能：按起始时间从TFS上获取某一路径下签入文件的最新版本    
    可选输入：起始时间（格式：2017-01-01 或 2017-01-01 10:10:10），默认为当天的0点  
*/  
using System;  
using System.IO;  
using System.Configuration;  
using Microsoft.TeamFoundation.Client;  
using Microsoft.TeamFoundation.VersionControl.Client;  
namespace TfsFetch
{  
    class Program
    {  
        //private System.Net.NetworkCredential netCred;  
        private TfsTeamProjectCollection tfsTeamProjCol;
        private VersionControlServer vcs;
        //private Workspace ws; 
        public Program()
        {
            string serverUrl = ConfigurationManager.AppSettings.Get("serverUrl");
            tfsTeamProjCol = new TfsTeamProjectCollection(new Uri(serverUrl));
            vcs = tfsTeamProjCol.GetService&lt;VersionControlServer&gt;(); 
            //ws = vcs.GetWorkspace(workSpacePath);
        }
        //获取签入文件的最新版本
        //startTime: 签入时间的最早边界
        public void GetLatestItems(DateTime startTime) {
            string tfsVerPath = ConfigurationManager.AppSettings.Get("tfsVerPath");
            ItemSet itemSet = vcs.GetItems(tfsVerPath, RecursionType.Full);
            string localRootPathWithDate =                 
            ConfigurationManager.AppSettings.Get("localRootPath") + "/" + 
            DateTime.Now.ToString("yyyyMMdd"); 
            string histLocalRootpath = ConfigurationManager.AppSettings.Get("histLocalRootpath"); 
            string histLocalRootpathWithDate = histLocalRootpath + "/" + 
            DateTime.Now.ToString("yyyyMMdd_hhmmss"); 
            if (Directory.Exists(localRootPathWithDate))
            //这里的前提是，实际开发中每天最多发一个版本进行测试，所以如果当天已经下载过版本，则需要将当天已下载的版本移到历史版本库中，以最新下载的为准
            {
                try
                {
                    if(!Directory.Exists(histLocalRootpath))
                    {                         
                        Directory.CreateDirectory(histLocalRootpath);
                    }
                    Directory.Move(localRootPathWithDate, histLocalRootpathWithDate);
                }                 
                catch (Exception)
                {                     
                    Console.WriteLine("Error: Moving folder failed");
                }
            }
            int dlCount = 0;
            foreach(Item item in itemSet.Items)
            {                 
                string excludedFolder =
                tfsVerPath + "/" + 
                ConfigurationManager.AppSettings.Get("excludedSubFolder");
                if (item.CheckinDate &gt;= startTime &amp;&amp;
                item.ServerItem.LastIndexOf(excludedFolder) == -1)
                {                     
                    Console.WriteLine(item.ServerItem);
                    Console.Write("Check-in time: " + item.CheckinDate);
                    string localPath = 
                    localRootPathWithDate + "/" + 
                    item.ServerItem.Substring(tfsVerPath.Length);
                    int folderLastIdx = localPath.LastIndexOf('/');
                    string folderPath = localPath.Substring(0, folderLastIdx);
                    if (! Directory.Exists(folderPath))
                    {                         
                        Directory.CreateDirectory(folderPath);
                    }                     
                    Console.Write("    ");
                    try
                    {
                        item.DownloadFile(localPath);
                        Console.WriteLine("Type: File");
                        dlCount++;
                    }
                    catch (Exception)
                    {
                        Console.Write("Type: Directory\n");
                    }
                    Console.WriteLine("");
                }
            }
            Console.WriteLine("\nDownloaded files count: " + dlCount);
        }
        static void Main(string[] args)
        {
            string startTimeStr = DateTime.Now.ToString("yyyy-MM-dd") + " 00:00:00";
            DateTime startTime = DateTime.Parse(startTimeStr);
            if (args.Length &lt; 1 || args[0] == "/help")
            {
                Console.WriteLine(
                "Example:\n" +
                "\tTfsFetch [dateTime]\n" +
                "\tdateTime: 2017-01-01 || 2017-01-01 12:30:30\n\n" +
                "\tDefault start time: " + startTimeStr + "\n"
                );
            }
            else if(args.Length &gt;= 1 &amp;&amp; args[0] != "/help")
            {
                switch (args.Length)
                {
                    case 1:
                        startTimeStr = args[0];
                        break;
                    case 2:
                        startTimeStr = args[0] + " " + args[1];
                        break;
                    default:
                        break;
                }
            }
            try
            {
                startTime = DateTime.Parse(startTimeStr);
            }
            catch(Exception)
            {
                Console.WriteLine("Error: Wrong time format");
                Console.ReadKey();
                return;
            }
            Console.WriteLine("Downloaded list:\n");
            Program prog = new Program();
            prog.GetLatestItems(startTime);
            Console.ReadKey();
        }
    }
} 
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How I Posted My First Blog on Github]]></title>
    <link href="http://foolishwolf.github.io/blog/2016/08/07/how-i-posted-my-first-blog-on-github/"/>
    <updated>2016-08-07T23:46:50+08:00</updated>
    <id>http://foolishwolf.github.io/blog/2016/08/07/how-i-posted-my-first-blog-on-github</id>
    <content type="html"><![CDATA[<p>This blog is mainly about how to post a blog on Github with Octopress, and the setup of a Markdown-style document editor - Sublime Text is also introduced.</p>

<h2>1. Octopress</h2>

<h3>What is Octopress</h3>

<p>Octopress is a blogging tool build with Ruby, and can be downloaded from Github.</p>

<h3>How to build the Octopress</h3>

<p>Here is the building process on Ubuntu, and it seems similar on other OS.</p>

<h4>Install Git</h4>

<pre><code>$sudo apt-get install git
</code></pre>

<h4>Install Ruby</h4>

<pre><code>$sudo apt-get install ruby ruby-dev
</code></pre>

<h4>Download Octopress</h4>

<p>Clone the octopress to local directory <em>octopress</em>:
<code>
$git clone git://github.com/imathis/octopress.git octopress
</code></p>

<h4>Install the dependencies</h4>

<p>Enter the directory of octopress:
<code>
$cd ocopress
</code>
And type in following command:
<code>
$gem install bundler
$rbenv rehash
$bundle install
</code></p>

<h4>Install default theme of Octopress</h4>

<pre><code>$rake install
</code></pre>

<h3>Initiate blog pages and commit source</h3>

<p>Before posting a new blog to Github, a respository with the name <em>yourname.github.io</em> is expected to bulid.
Then run the setup:
<code>
$rake setup_github_pages
</code>
Follow the instructions and type in the answers of what they ask.
Finally, generate and deploy your blog site onto Github:
<code>
$rake generate
$rake deploy
</code>
The source for your blog should also be committed:
<code>
$git add .
$git commit -m 'your comments'
$git push origin source
</code></p>

<h3>Posting a new blog</h3>

<p>Use command <code>rake new_post[]</code> to create a new blog file in <em>source/_post</em>:
<code>
$rake new_post['Title of Your New Blog']
</code>
Everytime before posting a new blog, command:
<code>
$rake generate
$rake deploy
</code>
should be run to generate the formatted blog and deploy it to Github.</p>

<h2>2. Local Markdown editor - Sublime Text</h2>

<p>After the Octopress is build, what we need now is a powerful editor helping to write a markdown-style document gracefully. And Sublime Text is just one perfect choice.</p>

<h3>Installation</h3>

<p>Sublime Text is a cross platform and sophisticated text editor for code, markup and prose. Once being installed and it can be evaluated for free. However, such a powerful editor does not directly enable markdown-style editing. Therefore, it is necessary to add markdown packages into Sublime Text.</p>

<p>Steps:</p>

<ul>
<li>Use <code>Ctrl+`</code> to call the console.</li>
<li>Copy following code into the command line of console:
```python
import urllib2,os; pf=&lsquo;Package Control.sublime-package&rsquo;; ipp = sublime.installed_packages_path(); os.makedirs( ipp ) if not os.path.exists(ipp) else None; urllib2.install_opener( urllib2.build_opener( urllib2.ProxyHandler( ))); open( os.path.join( ipp, pf), &lsquo;wb&rsquo; ).write( urllib2.urlopen( &lsquo;<a href="http://sublime.wbond.net/">http://sublime.wbond.net/</a>&rsquo; +pf.replace( &lsquo; &rsquo;,&lsquo;%20&rsquo; )).read()); print( &lsquo;Please restart Sublime Text to finish installation&rsquo;)</li>
</ul>


<p><code>``
- Press key</code>Enter<code>to run the code above and then restart Sublime Text 2.
- Use</code>Ctrl+Shift+P<code>to call the Command Palette.
- Type in</code>PCIP<code>and press key</code>Enter`.
- Type in key words to find package <strong><em>Markdown Preview</em></strong> and package <strong><em>Markdown Editing</em></strong>.
- Click and install these two packages.
- Done!</p>

<pre><code>Congratulations! Let us undertake to write blogs on Github!
</code></pre>
]]></content>
  </entry>
  
</feed>
